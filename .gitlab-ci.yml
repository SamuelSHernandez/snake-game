# Use the official gcc image
image: gitlab.cs.wallawalla.edu:5050/pridja/catch2-example:latest

before_script:
  # Install build dependencies
#  - apt-get update && apt-get install -y gcc g++ make cmake clang-format-6.0 git-core

stages:
  - analysis
  - build
  - test
  - coverage
  - deploy

check_formatting:
  stage: analysis
  script:
    - echo `which clang-format-6.0`
    - ln -s `which clang-format-6.0` /usr/bin/clang-format
    - echo $CI_PROJECT_DIR
    - cd "$CI_PROJECT_DIR"
    - linter_errors=$(git-clang-format-6.0 --commit "HEAD~1" -q --diff | grep -v --color=never "no modified files to format" || true)
    - echo "$linter_errors"
    - if [ ! -z "$linter_errors" ]; then echo "Detected formatting issues; please fix"; exit 1; else echo "Formatting is correct"; exit 0; fi

run_cpplint:
  stage: analysis
  before_script:
#    - apt-get update -y && apt-get install -y python-pip
#    - python -m pip install cpplint
  script:
    - cd src
    - find -name '*.h' -exec cpplint {} +
    - find -name '*.cpp' -exec cpplint {} +

run_cppcheck:
  stage: analysis
  script:
    - find -name '*.h' -exec cppcheck --enable=all --suppress=missingIncludeSystem --language=c++ {} +
    - find -name '*.cpp' -exec cppcheck --enable=all --suppress=missingIncludeSystem --language=c++ {} +

build_programs:
  stage: build
  script:
    - mkdir build
    - cd build
    - cmake ..
    - make
  artifacts:
    paths:
      - build/tests
      - build/program
    expire_in: 1 hour

snake_tests:
  stage: test
  script:
    - build/tests [snake]

game_tests:
  stage: test
  script:
    - build/tests [game]

code_coverage:
  stage: coverage
  script:
    - mkdir -p build && cd build
    - cmake .. -DGENERATE_CODE_COVERAGE=true
    - make
    - ./tests
    - cd CMakeFiles/tests.dir
    - mkdir -p cov
    - find -name '*.o' -exec cp -t cov {} +
    - find -name '*.gcno' -exec cp -t cov {} +
    - find -name '*.gcda' -exec cp -t cov {} +
    - cd cov || exit 1
    - find -name '*.o' -exec gcov -bf {} \; > /dev/null
    - lcov --quiet --capture --directory . --output-file coverage.info
    - lcov --quiet --remove coverage.info "*include*" -o coverage.info
    - lcov --list coverage.info
    - echo "Generating HTML Report"
    - genhtml coverage.info --output-directory out
    - echo "You can download the report from the pipleine artifacts in gitlab for the next week"
  artifacts:
    paths:
      - build/CMakeFiles/tests.dir/cov/out/
    expire_in: 7 days

deploy_prod:
  stage: deploy
  before_script:
    - apt-get update -qq
    - apt-get install -qq curl
    - 'which ssh-agent || ( apt-get install -qq openssh-client )'
    - eval $(ssh-agent -s)
    - ssh-add <(echo "$SSH_PRIVATE_KEY" | base64 -d -w 0)
    - mkdir -p ~/.ssh
    - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config'
  script:
    - ELF_NAME="${CI_PROJECT_NAMESPACE}-snake"
    - SSH_COMMAND_STRING="if pgrep ${ELF_NAME}; then pkill ${ELF_NAME}; fi && "
    # Double quotes around everything needed as it has a colon in it
    - "SSH_COMMAND_STRING+=\"curl --location --header 'PRIVATE-TOKEN: ${API_TOKEN}' '${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/jobs/artifacts/${CI_BUILD_REF_NAME}/raw/build/program?job=build_programs' --output ${ELF_NAME} &&\" "
    # Make sure the file is executable
    - SSH_COMMAND_STRING+="chmod +x ${ELF_NAME} && "
    # Start it in the background in such a way that SSH will not hang when we exit
    - SSH_COMMAND_STRING+="(nohup ./${ELF_NAME} ${RUN_PORT} > /dev/null 2>&1 &) && "
    # Make sure the program is running, if it is, we exit gracefully
    - SSH_COMMAND_STRING+="if pgrep ${ELF_NAME}; then exit; fi && "
    # If the program is not running, exit with an error code to say something went wrong
    - SSH_COMMAND_STRING+="exit 1"
    # Print it out so we can see what happened for debugging purposes.
    - echo "$SSH_COMMAND_STRING"
    # Execute the deploy
    - ssh $SSH_USER@$SSH_HOST "${SSH_COMMAND_STRING}"
    # Make sure it is running
    - "curl --location http://${SSH_HOST}:${RUN_PORT} | grep \"Go to /quote/# or /random to get a quote.\""
  when: manual
  only:
    - master

variables:
  JEKYLL_ENV: production
  LC_ALL: C.UTF-8

test:
  image: ruby:2.3
  stage: test
  script:
    - bundle install
    - cd docs
    - bundle exec jekyll build -d ../test
  artifacts:
    paths:
      - test
  # except:
  #   - master

pages:
  image: ruby:2.3
  stage: deploy
  script:
    - bundle install
    - cd docs
    - bundle exec jekyll build -d ../public
    - echo ${CI_PAGES_URL}
  artifacts:
    paths:
      - public
  # only:
  #   - cptr245_CI
